% !Mode:: "TeX:UTF-8"% !TEX TS-program = xelatex
% !TEX encoding = UTF-8 Unicode
% !Mode:: "TeX:UTF-8"

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
% This is a sample article script. All rights reserved.
% Author: qianhui@zju.edu.cn
%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\documentclass[a4paper,twoside,AutoFakeBold]{article}
% \usepackage{optreport}
\usepackage{./optreport}

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
% Some packages for this sample.
%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\usepackage{comment}	% Package for comment useless document
\usepackage{bm}			% Package for Bold-math symbol
\usepackage{mathrsfs}	% Package for RSFS fonts in maths
\usepackage{listings}	% Package for Listing code
\usepackage{enumerate}	% Package for enumerate
\usepackage{pdfrender}
\usepackage{subcaption}
\usepackage{multirow}
\usepackage{booktabs}
\usepackage{bbm}
\usepackage{bbding}
\usepackage{mathtools}
\usepackage{graphicx}
\usepackage{float}
\usepackage{epstopdf}
\usepackage{lipsum}
\usepackage{metalogo}

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
% Title, Authors, Reprot Time.
%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\serialnum{2020-3-109315041}

\rptname{Beck2009fast: A fast iterative shrinkage-thresholding algorithm for linear inverse problems}

\rptauthora{李文耀}{3231012302} %作者1和学号
\rptauthorb{施兴睿}{3230102392} %作者2和学号
% \rptauthorc{张三丰}{109315043} %作者3和学号
\reporttime{2025}{12}

% -------------------------------------------------
% for english version.
% -------------------------------------------------
\rptcontentsname{Contents}
\renewcommand{\abstractname}{{\xiaosan Abstract}}
\def\bibetal{et al.}
\def\biband{and}
\makeatletter
\renewcommand*{\ALG@name}{{\xiaosi Algorithm.~}}
\makeatother
\theoremstyle{definition}
\newtheorem{defn2}{{Definition}}
\newtheorem{corr2}{{Corrollary}}
\newtheorem{thrm2}{{Theorem}}
\newtheorem{lema2}{{Lemma}}
\newtheorem{exmp2}{{Example}}
\newtheorem{remark2}{{Remark}}
\renewcommand*{\proofname}{{\heiti Proof.~}}
\renewcommand{\figurename}{Fig.~}
\renewcommand{\tablename}{Tab.~}
\renewcommand{\refname}{Reference}
% -------------------------------------------------
%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
% Document.
%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\begin{document}
\pagenumbering{gobble}
%-----------------------------------------------------------------------------
%  Title Page
%-----------------------------------------------------------------------------
\maketitle
\thispagestyle{empty} % \cleardoublepage
\newpage
%-----------------------------------------------------------------------------
%  Table of Content
%-----------------------------------------------------------------------------
\rptcontent \thispagestyle{empty} % \cleardoublepage
\newpage
%-----------------------------------------------------------------------------
%  Abstract
%-----------------------------------------------------------------------------
\begin{abstract}\kaiti \xiaosi

本文针对信号与图像处理中的线性逆问题，研究了一类基于迭代收缩阈值（ISTA）的求解算法。传统ISTA方法结构简单、易于实现，适用于大规模甚至稠密矩阵问题，但其收敛速度较慢，仅具有次线性全局收敛速率 $O(1/k)$，限制了在实际高维问题中的应用效率。为此，论文作者提出了一种快速迭代收缩阈值算法（FISTA）。该算法在保留ISTA计算简洁性的基础上，通过引入一个由历史迭代点精心构造的辅助更新项，显著提升了收敛性能。理论分析表明，FISTA 在目标函数值意义下具有 $O(1/k^2)$ 的全局收敛速率，较传统 ISTA 有了质的飞跃。此外，论文还将FISTA推广至更一般的非光滑复合优化问题，即目标函数包含光滑凸项与非光滑凸正则项。数值实验以基于小波正则化的图像去模糊为例，对比了ISTA、FISTA 以及同期提出的 TWIST 算法。实验结果表明，FISTA 在恢复质量和收敛速度上均显著优于 ISTA，且往往在迭代次数上领先数个数量级，验证了其实际有效性。

\end{abstract}
\cleardoublepage

%-----------------------------------------------------------------------------
%  Sections
%-----------------------------------------------------------------------------
\pagenumbering{arabic}\songti\xiaosi
%-----------------------
%
%-----------------------
\section{论文概述}

\subsection{论文研究的问题背景}

线性逆问题广泛存在于天体物理学、信号与图像处理、统计推断和光学等多个学科领域，其核心任务是从受噪声污染的观测数据中恢复原始信号或图像。在这类问题中，观测数据通常可建模为一个离散线性系统
$$
\bm{A} \bm{x} = \bm{b} + \bm{w}
$$

其中 $\bm{A} \in \mathbb{R}^{m \times n}$ 是已知的线性算子矩阵，$\bm{x} \in \mathbb{R}^n$ 是待估计的原始信号，$\bm{b} \in \mathbb{R}^m$ 是观测数据，$\bm{w} \in \mathbb{R}^m$ 是加性噪声。由于实际应用中常常存在测量误差和噪声，直接求解该线性系统往往会导致不稳定或不准确的结果。因此，如何有效地解决线性逆问题成为了一个重要的研究课题。求解问题的目标可以被形式化为一个最小二乘（least squares）与稀疏正则化相结合的优化问题：
$$
\min_x \{ \|\bm{A}\bm{x} -\bm{b}\|^2 + \lambda \|\bm{x}\|_1 \}
$$

尽管 $l_1$ 正则化问题可转化为二阶锥规划并利用内点法求解，但在大规模问题中，$\bm{A}$ 通常是稠密矩阵，导致内点法在计算和存储方面的开销过大，难以满足实际应用中的实时性需求。而在本篇论文发表时，代收缩阈值算法（Iterative Shrinkage-Thresholding Algorithm, ISTA）常被使用来求解该类问题。

具体而言，ISTA 的一般步骤为：
$$
\bm{x}_{k+1} = \mathcal{T}_{\lambda t} \left( \bm{x}_k - 2t \bm{A}^T (\bm{A}\bm{x}_k - \bm{b}) \right)
$$

其中 $t$ 是适当的步长，$\mathcal{T}_{\alpha}: \mathbb{R}^n \rightarrow \mathbb{R}^n$ 是收缩阈值算子，定义为：
$$
\mathcal{T}_{\alpha}(\bm{x})_i = (|x_i| - \alpha)_+ \cdot \text{sign}(x_i)
$$

其中 $(z)_+ = \max(z, 0)$，下标 $i$ 表示向量的第 $i$ 个分量。

然而尽管 ISTA 结构简单、易于实现，但其收敛速度较慢，通常仅具有 $O(1/k)$ 的次线性全局收敛速率，这在处理大规模实际问题时效率较低。在本篇论文发表前，就已经有研究者在数学上证明了 ISTA 生成的序列 $\{\bm{x}_k\}$ 在某些关于算子 $\bm{A}$ 的病态条件下可能具有极慢并且任意差的渐进收敛速率。因此，如何加速 ISTA 的收敛速度成为了一个重要的研究方向。本文正是在此背景下，针对 $l_1$ 正则化线性逆问题，提出了一种快速迭代收缩阈值算法（FISTA），旨在显著提升收敛效率，同时适用于更一般的非光滑复合优化问题。

\subsection{论文的贡献}

本文的核心贡献是提出了一种名为 FISTA（Fast Iterative Shrinkage-Thresholding Algorithm） 的新算法，该算法在保持 ISTA 计算简单性的同时，显著提高了全局收敛速度，并从理论和实验两方面验证了其优越性。具体贡献包括以下几个方面：

\begin{enumerate}
    \item 理论层面：完成了 ISTA 算法的收敛性证明，提出快速迭代收缩阈值算法（FISTA）并完成收敛性证明。\\
        针对 ISTA 的慢收敛缺陷，本篇论文结合了 Nesterov 的加速思想与近端操作的适配性设计，构建了 FISTA 算法框架，还证明了 ISTA 的全局收敛速度为 $O(1/k)$，而 FISTA 则达到了 $O(1/k^2)$ 的全局收敛速率，显著优于 ISTA。这一改进是通过引入一个由历史迭代点精心构造的辅助更新点 $\bm{y}_k$ 实现的，该点由前两步迭代结果的线性组合生成，形式上为
        $$
        \bm{y}_{k+1} = \bm{x}_k + \frac{t_k}{t_{k+1}} (\bm{x}_k - \bm{x}_{k-1})
        $$
        其中 $t_k$ 按特定递归更新。这不仅降低了迭代次数的理论复杂度，还为算法在实际场景中的加速效果提供了数学保证。

        同时，这篇论文中给出的理论分析具有通用性，可处理包含任意凸非光滑正则项和任意光滑凸函数的目标函数，不局限于 $l_1$ 正则化和最小二乘损失，这使得 FISTA 能够广泛应用于各种实际问题。
    \item 实验层面：通过图像去模糊任务验证 FISTA 的性能优势。\\
        这篇论文通过在基于小波的图像去模糊问题上对比 ISTA、FISTA 以及当时最新的 TWIST 算法，实验表明 FISTA 在收敛速度上显著优于 ISTA，性能较 ISTA 提升数个数量级。在无噪声的简单测试图像恢复实验中，FISTA 仅用几百次迭代即可达到 ISTA 和 TWIST 需上万次迭代才能接近的精度。
\end{enumerate}

\subsection{论文组织}

\subsubsection{章节结构}

\begin{itemize}
    \item 第一节：引言。\\
        这一部分系统性地阐述了研究背景与问题动机，指出了线性逆问题在多个领域的重要性，分析了传统 ISTA 方法的不足，并明确了提出 FISTA 的必要性和意义。
    \item 第二节：理论分析基础。\\
        这一张回顾了基于梯度的优化方法（如梯度下降、近端梯度等）的基础结论，为后续分析 ISTA 和 FISTA 提供工具。
    \item 第三节：ISTA 的全局收敛速率证明
        这一张专注于分析 ISTA 算法的收敛性能，通过理论证明 ISTA 的全局收敛速率上界为 $O(1/k)$，指出了潜在的改进方向，为后续 FISTA 的改进提供对比基准。
    \item 第四节：提出 FISTA 算法并分析其收敛性。\\
        这一节详细介绍了 FISTA 的算法框架，阐述了其设计思想，并通过严谨的数学证明，展示了 FISTA 在目标函数值意义下能达到 $O(1/k^2)$ 的全局收敛速率，显著优于 ISTA。
    \item 第五节：数值实验。\\
        这一节通过一系列数值实验，特别是在图像去模糊任务上的应用，验证了 FISTA 的实际性能。实验结果显示，FISTA 在收敛速度和恢复质量上均优于 ISTA 和同期提出的 TWIST，证明了其在实际问题中的有效性。
\end{itemize}

\subsubsection{记号使用}

\begin{itemize}
    \item 两个向量 $\bm{x}, \bm{y} \in \mathbb{R}^n$ 的内积定义为 $\langle \bm{x}, \bm{y} \rangle = \bm{x}^T \bm{y}$。
    \item 矩阵 $\bm{A}$ 的最大特征值记为 $\lambda_{\max}(\bm{A})$。
    \item $\|\bm{x}\|$ 表示向量 $\bm{x}$ 的欧几里得范数。
    \item 矩阵 $\bm{A}$ 的谱范数定义记为 $\|\bm{A}\|$。
\end{itemize}



%-----------------------
%
%-----------------------
\section{相关工作}\label{section:related}

在本篇论文发表的前一段时间，有许多其他研究者也在致力于开发能提升ISTA性能的替代算法。与这篇论文提出的 FISTA 类似，这些方法不仅基于前一个迭代点，还依赖于先前计算的前两个或更多个迭代点来计算下一个迭代点。其中一条研究路径聚焦于改进 ISTA 本身，\citeauthor{bioucas-dias2007new} 提出的TWIST（两步迭代收缩/阈值）算法及其单调版本 \cite{bioucas-dias2007new} 在对问题数据和算法参数的某些假设下，能够收敛到形如
$$
\|\bm{A}\bm{x} - \bm{b}\|^2 + \varphi(\bm{x})
$$

的目标函数的极小值点，其中 $\varphi$ 是凸的非光滑正则项。TWIST 算法在当时已被验证在各类线性逆问题上效率均高于 ISTA。

而另一条尝试对同一类问题的 ISTA 进行加速的研究线路则是由 \cite{elad2007subspace} 提出的。该方法采用序列子空间优化技术进行研究，通过在一个仿射子空间上最小化函数来生成下一个迭代点，其中这个仿射子空间由两个或多个先前迭代点和当前梯度张成。这种方法的加速效果已在去噪应用问题的数值实验上得到证实。但是上述这两种方法 \cite{bioucas-dias2007new} 和 \cite{elad2007subspace} 都没有建立起对全局非渐进速率的理论分析。

在这篇论文投稿后，本篇论文的作者了解到 \citeauthor{nesterov2007gradient} 独立研究了一种加速梯度类方法的多步版本 \cite{nesterov2007gradient}。该方法与 FISTA 可以被证明在函数值上以 $O(1/k^2)$ 的速率收敛，但两者在概念和计算上都有所不同。首先，\cite{nesterov2007gradient} 利用过去迭代的累积历史递归构建一个近似函数序列 $\psi_k(\cdot)$ 来逼近 $F(\cdot)$，而 FISTA 则仅需要使用一个常规的投影类步骤。其次，\cite{nesterov2007gradient} 的方法需要在每次迭代中需要计算两次投影类操作，而 FISTA 每次迭代只需计算一次，在计算效率上更具优势，因此 FISTA 给出的方法相较于 \cite{nesterov2007gradient} 是完全不同的。


%-----------------------
%
%-----------------------
% \section{问题描述和常用记号}\label{section:preliminary}
% 本节主要描述处理的问题，并解释常用的记号。

% {\color{blue} 例如，分布式优化问题是一类重要的计算问题，在机器学习领域有大量的应用。分布式优化问题可以描述为如下形式。
% \begin{equation}\label{eq:formulation}
% \min_{x \in Q} \sum_{j \in \mathcal{N}} f_j(x).
% \end{equation}
% 在式(\ref{eq:formulation})中，$Q$是约束集合；$\mathcal{N}$是一个网络节点的索引集合；$f_j$是在$j$节点上的目标函数。
% }

% \lipsum[7]

%-----------------------
%
%-----------------------


%-----------------------
%
%-----------------------
\section{方法描述}\label{section:methods}

我们的目标是：

\[\min_x \{ \|\bm{A}\bm{x} -\bm{b}\|^2 + \lambda \|\bm{x}\|_1 \}\]

不妨令我们要求函数最小值：$F(\bm{x}) = \min_x \{ \|\bm{A}\bm{x} -\bm{b}\|^2 + \lambda \|\bm{x}\|_1 \}$

拆开为 $f(\bm{x}) = \|\bm{A}\bm{x} -\bm{b}\|^2$ 和 $g(\bm{x}) = \lambda \|\bm{x}\|_1$

\[Q_{L}(x, y):=f(y)+<x-y, \nabla f(y)>+\frac{L}{2}\| x-y\| ^{2}+g(x),\]


\[p_{L}(y)=\underset{x}{argmin}\left\{g(x)+\frac{L}{2}\left\| x-\left(y-\frac{1}{L} \nabla f(y)\right)\right\| ^{2}\right\}\]


\subsection{固定步长策略}

已知 \( f \) 的梯度 Lipschitz 常数 \( L = L(f) \)，即满足

\[\|\nabla f(x) - \nabla f(y)\| \leq L \|x - y\|, \quad \forall x, y.\]

\begin{algorithm}[h]
	\caption{FISTA with constant stepsize}
	\label{alg:fista_const}
	\begin{algorithmic}
	\REQUIRE Lipschitz constant $L = L(f)$, initial point $x_0$
	\ENSURE Sequence $\{x_k\}$ converging to solution of $\min f(x) + g(x)$
	\STATE Set $y_1 \gets x_0$, $t_1 \gets 1$
	\FOR{$k = 1, 2, \dots$}
		\STATE Compute $x_k \gets \arg\min_x \left\{ g(x) + \frac{L}{2} \left\| x - \left( y_k - \frac{1}{L} \nabla f(y_k) \right) \right\|^2 \right\}$
		\STATE Update $t_{k+1} \gets \frac{1 + \sqrt{1 + 4 t_k^2}}{2}$
		\STATE Update $y_{k+1} \gets x_k + \frac{t_k - 1}{t_{k+1}} (x_k - x_{k-1})$
	\ENDFOR
\end{algorithmic}
\end{algorithm}


\subsection{自适应步长策略}

当 \( L(f) \) 未知或难以计算时，采用自适应步长策略。从一个初始猜测 \( L_0 > 0 \) 开始，逐步增大步长（即减小实际步长 \( 1/L \)），直到满足下降条件：

\[F(p_L(y_k)) \leq Q_L(p_L(y_k), y_k)\]


\begin{algorithm}[h]
	\caption{FISTA with backtracking}
	\label{alg:fista_backtrack}
	\begin{algorithmic}
	\REQUIRE Initial point $x_0$, initial stepsize estimate $L_0 > 0$, $\eta > 1$
	\ENSURE Sequence $\{x_k\}$ converging to solution
	\STATE Set $y_1 \gets x_0$, $t_1 \gets 1$, $L \gets L_0$
	\FOR{$k = 1, 2, \dots$}
		\REPEAT
			\STATE $L \gets \eta L$
			\STATE $x_{\text{temp}} \gets \arg\min_x \left\{ g(x) + \frac{L}{2} \left\| x - \left( y_k - \frac{1}{L} \nabla f(y_k) \right) \right\|^2 \right\}$
			\STATE Evaluate $Q \gets f(y_k) + \langle  x_{\text{temp}} - y_k ,\nabla f(y_k) \rangle + \frac{L}{2} \|x_{\text{temp}} - y_k\|^2 + g(x_{\text{temp}})$
		\UNTIL{$f(x_{\text{temp}}) + g(x_{\text{temp}}) \leq Q$}
		\STATE Set $x_k \gets x_{\text{temp}}$, $L_k \gets L$
		\STATE Update $t_{k+1} \gets \frac{1 + \sqrt{1 + 4 t_k^2}}{2}$
		\STATE Update $y_{k+1} \gets x_k + \frac{t_k - 1}{t_{k+1}} (x_k - x_{k-1})$
	\ENDFOR
\end{algorithmic}
\end{algorithm}


%-----------------------
%
%-----------------------

\section{论文的实验结果}

\subsection{实验设置与控制变量}

\subsubsection{问题模型}

所有实验都针对用 L1 正则化在小波域中对模糊图像进行去模糊。具体形式为优化问题 $\min_x F(x) = \|A \bm{x} - b\|^2 + \lambda \|x \|_1$。
其中 $A = RW$，$R$ 是模糊算子矩阵，$W$ 是逆小波变换矩阵。$b$ 是已知的观测到的模糊图像。$\bm{x}$ 是我们要求解的小波域稀疏系数。$\lambda >0$ 控制正则化强度

每张图片都被展开为一个一维的 $[0,1]^{h \times w}$ 向量，其中 $h$ 和 $w$ 分别是图像的高度和宽度，每个像素被归一化到 $[0,1]$ 区间。

\subsubsection{算力}

所有对比算法（ISTA, FISTA, MTWIST）在每一步迭代中的计算量都是相同的：一次 $A$ 和 $A^T$ 的矩阵-向量乘法，以及一次对小波系数的软阈值操作。

\subsubsection{步长策略}

所有方法均使用恒定步长，步长设置为 $\frac{1}{L(f)}$，其中$L(f)$是光滑项$f(x) = \|A \bm{x} - b \|^2$ 的梯度 Lipschitz 常数。


\subsubsection{迭代起点}

在所有实验中，算法的初始解 $\bm{x}_0$ 都被设为生成的模糊图像表示的向量。

\subsubsection{边界条件}

所有实验均假设反射（Neumann boundary conditions），在图像边界之外的像素值，通过对边界附近的已有像素进行镜像反射来定义。

\subsubsection{评估指标}

主要的量化评估指标是目标函数值 $F(\bm{x}_k)$，即 $\|A \bm{x}_k - b \|^2 + \lambda \|\bm{x}_k \|_1$ 在相同迭代次数 $k$ 之下越小越好。

同时也通过相同迭代次数下恢复图像的清晰度进行定性评估。

\subsection{Cameraman 图像去模糊}

\subsubsection{测试数据}

标准的 $256 \times 256$ “摄影师” 测试图像。


使用 $9 \times 9$ 高斯模糊核，标准差为 $4$，使用 MATLAB 函数 imfilter 与 fspecial 实现。

添加零均值、标准差为 $10^{-3}$ 的高斯白噪声。


参数 $\lambda = 2e-5$。


\begin{figure}[htbp]
	\centering
	\includegraphics[width=\linewidth]{figs/test_data1}
	\caption[Cameraman 图像去模糊的实验数据]{}
\end{figure}


\subsubsection{实验结果}

ISTA、MTWIST 和 FISTA 在100次和200次迭代后的恢复图像及对应的目标函数值 $F_{100}$ 和 $F_{200}$。可以发现无论是目标函数大小还是肉眼观察定性分析，FISTA 都优于 ISTA 和 MTWIST。


\begin{figure}[htbp]
	\centering
	\includegraphics[width=\linewidth]{figs/test_res1}
	\caption[Cameraman 图像去模糊的实验结果]{}
\end{figure}


\subsection{Simple Test Image 图像去模糊}

\subsubsection{测试数据}

一个 $256 \times 256$ 的简单测试图像（来自 Hansen 的正则化工具箱）。使用 $9 \times 9$ 高斯模糊核，标准差为 $4$，使用 MATLAB 函数 imfilter 与 fspecial 实现。添加零均值、标准差为 $10^{-3}$ 的高斯白噪声。

参数 $\lambda = 1e-4$。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=\linewidth]{figs/test_data2}
	\caption[Simple Test Image 图像去模糊的实验数据]{}
\end{figure}

\subsubsection{实验结果}

同样展示了 100次和 200次迭代后的结果。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=\linewidth]{figs/test_res2}
	\caption[Simple Test Image 图像去模糊的实验结果]{}
\end{figure}


文章还汇报了更多的实验结果：

\begin{enumerate}
\item FISTA 迭代 100 次后得到的目标函数值为 0.321，MTWIST 需要迭代 416 次才能达到 FISTA 迭代 100 次时的目标函数值

\item 要达到 FISTA 迭代 200 次时的目标函数值 0.309，MTWIST 则需要迭代 1102 次。

\item ISTA 的目标函数值停滞在 0.323 附近，而 MTWIST 的目标函数值则停滞在 0.318 附近。

\end{enumerate}

\subsection{无噪声情况下的收敛精度极限测试}


为了在一个已知最优解的场景下，严格测试各算法能达到的最终收敛精度。

\subsubsection{测试数据}

使用一个 $64 \times 64$ 的全零图像作为原始图像。
使用 $9 \times 9$ 高斯模糊核，标准差为 $4$，使用 MATLAB 函数 imfilter 与 fspecial 实现。
不添加噪声。

参数 $\lambda = 0$


\subsubsection{实验结果}

绘制了 10000次 迭代过程中，三种算法的误差 $\log(F(\bm{x}_k) - F(\bm{x}^*))$ 曲线。


\begin{figure}[htbp]
	\centering
	\includegraphics[width=\linewidth]{figs/test_res3}
	\caption[简单案例下的收敛速度]{}
\end{figure}


%-----------------------
%
%-----------------------
\section{论文的结论}

\subsection{理论结果}

\subsubsection{ISTA 的收敛性分析}

${\bm{x}_{k}}$ 是固定步长或者带回溯准则的 ISTA 算法的迭代解，则有 $\forall k \geq 1$ 

\[(3.5) F\left(x_{k}\right)-F\left(x^{*}\right) \leq \frac{\alpha L(f)\left\| x_{0}-x^{*}\right\| ^{2}}{2 k} \forall x^{*} \in X_{*},\]

固定步长时 \(\alpha=1\) ，带回溯准则时 \(\alpha=\eta\) 。

显然，因为 $e_k = F(\bm{x}_k) - F(\bm{x}^*) \leq \frac{C}{k}$ ，迭代收缩阈值算法（ISTA）的最坏情况复杂度为 $O(1/k)$。


\subsubsection{FISTA 的收敛性分析}

FISTA 算法的迭代解 \({x_{k}}\) , \({y_{k}}\) ，那么 \(\forall k \geq 1\) 

\[F\left(\bm{x}_{k}\right)-F\left(\bm{x}^{*}\right) \leq \frac{2 \alpha L(f)\left\| \bm{x}_{0}-\bm{x}^{*}\right\| ^{2}}{(k+1)^{2}} \forall \bm{x}^{*} \in \bm{X}_{*},\]

那么不难看出，$e_k = F(\bm{x}_k) - F(\bm{x}^*) \leq \frac{C}{k^2}$，改进版的迭代收缩阈值算法 FISTA，复杂度收敛至 $O(1/k^2)$。

\subsection{实验结果}

要达到指定精度，快速迭代收缩阈值算法（FISTA）所需的迭代次数远少于迭代收缩阈值算法（ISTA），性能优势显著。
将快速迭代收缩阈值算法（FISTA）与单调版 TWIST 算法（MTWIST）对比，也可得出类似结论。


同时，FISTA 算法收敛到的最佳精度远远高于 ISTA 算法和 MTWIST 算法。


\section{附录}

\begin{defn2}[规范数]\label{defn:theone}
如果$x \in (0,1)$，则称$x$为规范数。
\end{defn2}
\begin{lema2}\label{lema:theone}
如果$x \in [0,1]$，则存在单调函数$\mathcal{G}(x)$ 有$\mathcal{G}(x) \geq f(x)$。
\end{lema2}
根据引理\ref{lema:theone}可以得到我们给出如下定理。
\begin{thrm2}\label{thrm:theone}
如果$x \in [0,1]$，则有$f(x) \geq f(y) + (x-y)^{\top} \nabla \mathcal{G}(x)$ 当且仅当 $f(\cdot)$是凸函数。
\end{thrm2}
根据定理\ref{thrm:theone}可以得到如下推论。
\begin{corr2}\label{corr:theone}
如果$x \in [0,1]$，则有$f(x)$是单调函数。
\end{corr2}
\begin{proof}
引理证明如下。
\end{proof}
\begin{exmp2}\label{corr:theone}
$f(x)= ax + b$，其中$a>0$。
\end{exmp2}

\begin{remark2}\label{remark:theone}
$f(x)$是单调函数。
\end{remark2}


%-----------------------
%
%-----------------------
\section{论文存在的问题}\label{section:problem}

\subsection{性能问题}

Barbastathis 等研究者在其综述\cite{barbastathis2019use} 中指出，通过迭代来获取结果的图像修复方法均存在着性能问题，主要原因在于迭代计算量大且难以并行，这导致即使是 FISTA 算法在实时应用中也难以达到神经网络的性能。

Bottou 等研究者在其关于大规模机器学习的综述\cite{bottou2018optimization}中提到 FISTA 是一种全梯度方法，因此计算量相对于随机方法很大。

Nehme 等研究者\cite{nehme2018deep}提出在实际的图像处理应用中，所有依赖于迭代优化和参数调优的传统方法，FISTA 方法是其中优秀的代表，都存在速度慢和可扩展性差的根本缺陷。因为实际的应用中，图片为了达到较高的精度会使用很高的像素，这导致网格会很大，造成 FISTA 算法性能很低。

\subsection{应用困难}

Yang 等研究者在其对于图像压缩感知（CS）的研究 \cite{yang2018admm}中阐述了以 FISTA 为代表的一系列迭代算法存在若干需要手动调优或依赖经验设置的因素，例如迭代步长、参数 $\lambda$ 等，如果设置不当会极大的影响性能。Mou 在其关于图像处理的论文\cite{mou2022deep}也提到了这一点。


\subsection{成果难以适应越来越高的要求}

Chung 等研究者在其关于图像生成的论文 \cite{chung2022improving}中指出，FISTA 算法需要手工设计正则项来完成工作，随着问题越来越复杂，简单的设计效果不佳。

Song 等研究者在其影像学研究的实验中\cite{song2021solving}，使用 FISTA 算法去模糊图像，发现有许多伪影，而且也存在上文提到的性能问题。

\section{围绕这篇论文可以开展哪些可行的研究}\label{section:application}

\subsection{应用层面}

\subsubsection{医学领域}

本文方法在影像学中多有应用。

Song 等研究者\cite{song2021solving} 提出 FISTA 方法可以用于影像学图像处理。Aggarwal 等研究者在为优化磁共振成像（MRI）质量设计神经网络的的工作中\cite{aggarwal2018modl}，提到收敛速度很慢，提出可以使用本文方法大大加快收敛速度。

同时也是这篇工作提到，如本文这种快速且准确的图像修复方法，在计算机断层扫描（CT）\cite{elbakri2002statistical}、正电子发射断层显像（PET）\cite{verhaeghe2008dynamic}等医学影像学领域、和显微镜成像\cite{aguet2008model}等生物医学领域也可以起到重要的作用。 

\subsubsection{物理学领域}

Nehme 等研究者在其关于显微镜图像处理的研究中\cite{nehme2018deep}提出 FISTA 曾经是一种处理显微镜图像的优秀算法。


\subsubsection{图像处理领域}

本文研究的是图像去模糊领域，自然对于图像感知\cite{barbastathis2019use}等领域有很大的理论价值。

Chung 等研究者在其关于图像生成的论文 \cite{chung2022improving}中指出，将需要生成图像的空白作为噪声部分，FISTA 算法是一种传统的图像生成方法基准，说明曾经 FISTA 算法也是图像生成的重要算法。


\subsection{计算机科学层面}

本文的方法 FISTA 算法的理论基础是凸优化，因此可以应用到其他凸优化问题中，也可以引入机器学习领域。

Sun 等研究者在其研究非凸极小极大鞍点博弈（Non-Convex Min-Max Saddle Point Games）的数值优化的论文\cite{sun2016majorization}中，使用了本文的加速梯度优化思想。

Lin 等研究者，在关于 CNN 的结构化剪枝的研究\cite{lin2019towards}中，采用FISTA快速且可靠地移除冗余神经网络。



\subsection{未来展望}

许多研究者对于本文方法也提出了很多有益的优化思路。

Zhang 等研究者在对于图像去模糊问题\cite{zhang2017learning}的研究中，提出可以训练好的CNN去噪器来替代 FISTA 这类迭代方法中原有的去噪操作。

Mou 等研究者在其关于图像修复的论文\cite{mou2022deep}中，使用了基于 FISTA 方法修改的基于机器学习的方法，将依赖于经验的 $A$ 矩阵和正则化项替换为了神经网络，研究了包括图像去雨（Image Deraining）、图像去模糊（Image Deblurring）、图像去噪（Image Denoising）和压缩感知（Compressive Sensing）等多个小领域。wang 等研究者在其相近领域的文章 \cite{wang2020model} 提出了相近的思路。



阐述上述理论有哪些应用，可以列举使用了上述理论的论文、专利、软硬件产品等。



%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
% Bibliography
%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\bibliographystyle{gbt7714-plain}
\bibliography{main}

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\end{document}
%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


